<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>C++ is the new COBOL | Klebstoff</title>
<meta name=keywords content="programming-languages">
<meta name=description content="C++ is a great language. As much as I hate it I cannot ignore how important it is and how much it brought to the table in it&rsquo;s 36 years of existence. I have tremendous respect for Bjarne Stroustrup for creating the so-called C with classes and I personally think that it&rsquo;s one of the best things that happened in programming language designs around the time when it came to existence.">
<meta name=author content>
<link rel=canonical href=http://kjczarne.github.io/2021-12-21-c-is-the-new-cobol/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://kjczarne.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=http://kjczarne.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=http://kjczarne.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=http://kjczarne.github.io/apple-touch-icon.png>
<link rel=mask-icon href=http://kjczarne.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.92.0">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><meta property="og:title" content="C++ is the new COBOL">
<meta property="og:description" content="C++ is a great language. As much as I hate it I cannot ignore how important it is and how much it brought to the table in it&rsquo;s 36 years of existence. I have tremendous respect for Bjarne Stroustrup for creating the so-called C with classes and I personally think that it&rsquo;s one of the best things that happened in programming language designs around the time when it came to existence.">
<meta property="og:type" content="article">
<meta property="og:url" content="http://kjczarne.github.io/2021-12-21-c-is-the-new-cobol/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-12-21T22:34:07+01:00">
<meta property="article:modified_time" content="2021-12-21T22:34:07+01:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="C++ is the new COBOL">
<meta name=twitter:description content="C++ is a great language. As much as I hate it I cannot ignore how important it is and how much it brought to the table in it&rsquo;s 36 years of existence. I have tremendous respect for Bjarne Stroustrup for creating the so-called C with classes and I personally think that it&rsquo;s one of the best things that happened in programming language designs around the time when it came to existence.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://kjczarne.github.io/posts/"},{"@type":"ListItem","position":2,"name":"C++ is the new COBOL","item":"http://kjczarne.github.io/2021-12-21-c-is-the-new-cobol/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++ is the new COBOL","name":"C\u002b\u002b is the new COBOL","description":"C++ is a great language. As much as I hate it I cannot ignore how important it is and how much it brought to the table in it\u0026rsquo;s 36 years of existence. I have tremendous respect for Bjarne Stroustrup for creating the so-called C with classes and I personally think that it\u0026rsquo;s one of the best things that happened in programming language designs around the time when it came to existence.","keywords":["programming-languages"],"articleBody":"C++ is a great language. As much as I hate it I cannot ignore how important it is and how much it brought to the table in it‚Äôs 36 years of existence. I have tremendous respect for Bjarne Stroustrup for creating the so-called C with classes and I personally think that it‚Äôs one of the best things that happened in programming language designs around the time when it came to existence.\nBut C++ is a language that we might slowly see becoming legacy technology. Here‚Äôs my take on the whole C++ shebang.\n üëÄ For context: I started my career as a software developer with JavaScript and Python and then worked with C# for a good few months. I haven‚Äôt touched C++ until a few months ago simply because I never had a need to. But there are situations in which you will need a much faster language that compiles to native code instead of something that always incurs a massive interpreter overhead. For the past two months I‚Äôve been learning C++ with the support of expert developers at work. My view may be a bit simplistic and I‚Äôd enjoy to start a discussion and hear other views. I made sure it‚Äôs not my resistance to change that makes me dislike C++ but this article naturally deals with some speculations about the future which we cannot know for certain, hence if you see that I‚Äôve overlooked something, don‚Äôt hesitate to point it out.\n  üëâ In the examples below I will be using C++17 because that‚Äôs what I‚Äôm using at work. Keep in mind that some of the examples that I describe, e.g. template constraints have been added with the C++20 standard. Why aren‚Äôt we using C++20? Well, using the latest standard is one of the problems I listed, so read on to learn more.\n The problems with C++ So, let‚Äôs start with the reasons that I dislike C++. I like to call them genuine problems.\nC++ is extremely verbose Creating production-level code in C++ ofter requires a lot of boilerplate. This is bad because large codebases usually incur higher maintenance costs. On top of that, the syntax of the language doesn‚Äôt make things better. Take for example the following template declaration which roughly corresponds to a very liberal generic type:\ntemplate typename T void do_something(T i) { if constexpr (std::is_integraluint8_t(array)) { // ...  } else { // ...  } } Compare that to a generic function in Rust:\nfn do_somethingT: u8(i: T) - () { // ... } This relative verbosity is prevalent in nearly all constructs. You quickly get sick of std::string make_string_repr(std::shared_ptr, std::string str_template) and you promptly swivel your display from vertical orientation back to landscape (happened to me). In general C++ tends to be way more verbose than languages like Python, though you can learn to make things more concise over time. An expert friend of mine at work once refactored a function I‚Äôve created from 70 lines down to about 10. And this is a nice seguey into our next talking point‚Ä¶\nIt takes years to get proficient in C++ The complexity of the language entails this naturally - you cannot become a good junior developer within a few months. Well, at least if you‚Äôre average like me, you will make a lot of mistakes especially at the very beginning of your journey. It is an immensely complex language especially for beginners or people comming from higher-level interpreted languages.\nMemory safety is not guaranteed Another issue/feature of C++ is the fact that the developer has to think about memory management very consciously all the time. For example, the following code compiles:\nvoid do_something() { int some_int; // a lot of code ...  int* unknown_int_ptr; // a lot of code ...  int* some_int_ptr = \u0026some_int; } Imagine that between the declaration of the integer and the declaration of the pointer you placed a lot of code and nowhere have you actually assigned a value to the some_int variable. This generally results in so-called undefined behavior, which is basically compiler-dependent and not guaranteed by the standard. So some_int_ptr when dereferenced will point to some_int but we cannot make any guarantees about its value, because it won‚Äôt make any sense anyway. And this statement is legal in C++ as it is in C.\nNow to the unknown_int_ptr. Notice that it has no address assigned so it essentially is a pointer into nothingness. Again this code compiles. Some smarter compilers might point out that this might be a bug but that depends on the way you‚Äôve set up your build toolchain. If you dereference unknown_int_ptr you will actually attempt dereferencing a nullptr which is also undefined behavior and in some cases pretty hard to catch!\nIn Rust, this is explicitly disallowed when using references:\nfn do_something() { let some_int: u8; // won't compile!  let unknown_int_ptr: \u0026u8; // won't compile!  let some_int_ptr: \u0026u8 = \u0026some_int; // won't compile! }  üëÄ The reason why C and C++ do allow such silly operations is to give the developers maximum flexibility with their code. As such, it is the sole responsibility of the developer not to make such mistakes. (Un)fortunately developers are born to make mistakes. Rust takes a middle ground. It is still possible to do unsafe operations in Rust, albeit they need to be explicitly marked (placed in an unsafe { } block).\n  üëÄ Some of the pointer management problems can be averted by using the so-called smart pointers which have been added in C++17. You can even emulate Rust‚Äôs ownership move logic with std::unique_ptr template. If you‚Äôre unsure what this all means just disregard this block.\n Using the latest standard might be risky I didn‚Äôt experience this personally but I‚Äôve heard of a commercial project (of which details I cannot disclose) that was implemented in C++17 back when C++17 was a freshly released standard. Long story short, the MSVC Compiler had a bug that caused the developers a lot of headaches before they were able to realize that their code is ok but the compiler is not. You would think that such things are unacceptable but bugs happen in every compiler or interpreter out there. The problem is - when you‚Äôre working with a complex language like C++ it‚Äôs inherently more likely that someone at some point will make a mistake. And that means you have to put lower trust into something as important as the compiler for the language.\nFiguring out build systems is ridiculously complicated My first look at the CMake-based build system generator toolchain in a large commercial project almost made me want to sign up for a 3 month break from work at a mental asylum. Now listen‚Ä¶\nIn Python we usually need one or more setup.cfg files with a corresponding setup.py that loads it, finds the package files and the package is ready to be installed. Python uses the pip package manager for this, Node.JS has npm or yarn package managers, Rust has its absolutely phenomenal cargo package manager.\n ü§¶‚Äç‚ôÇÔ∏è C++ does not have any good package manager whatsoever.\n The closest we have to a package manager in C++ is the Conan package manager. So let‚Äôs say I want to depend on a few packages in my C++ project. What do I do? I need to nearly write my own build system using CMake and use Conan CMake files to even be able to talk to the package manager when invoking cmake. CMake actually generates Makefile on Linux or Visual Studio Solution files on Windows. Well, not always, depends on how you configure it. Because you could replace Makefile-consuming make with ninja which can also be used as an alternative to MSBuild on Windows, MSBuild being the tool normally responsible for building Solution (*.sln) files. Then you have to remember that cached Conan packages can sometimes interfere with fresh builds if certain configuration options like the version of the compiler has changed in between builds, so does the CMake target directory with its CMakeCacher.txt‚Ä¶ üò£\nThere‚Äôs a beautiful German adjective that describes this situation perfectly: bescheuert.\n üëâ In Rust to obtain packages necessary for a new project, all you need to do is add them to the list of dependencies in Cargo.toml and trigger a new project build. That‚Äôs it. That‚Äôs what dependency management should look like.\n Compiler error messages can be next to useless Last but not least, if you‚Äôve ever compiled C++ code in your life you will know what I mean. The output produced by the compiler (especially MSVC) is usually quite uninformative and it often leads you on a wild goose chase. It happened to me lately that when using fmt I wasn‚Äôt able to find an improper usage of a formatter function because the line number info was hidden somewhere in the middle of an outlandishly long stack trace and my eyes just kept on slipping through it. It‚Äôs often very hard to debug weird compilation errors particularly where macros and templates are used.\nUltimately, why so many problems C++ has so many issues because it‚Äôs fairly old! Each new standard piled dubious features on top of the existing stuff with regards for maximum backwards-compatibility. Since a path has been taken with many language design choices, it is not really possible to now backtrack on certain decisions. Issues are being fixed and developer experience is being improved, albeit at a much slower pace than for most modern languages.\nWhy I think C++ is heading for the Elysian Fields You might have noticed that all examples I‚Äôve provided for the bad stuff in C++, I‚Äôve countered with examples in Rust. So, here‚Äôs my theory:\n üëâ I think Rust will replace C++ as the main systems development low(er)-level language within the next 20 years.\n If the pace of adoption of Rust Programming Language keeps up, we might see Rust being the language that solves some of the issues that C and C++ faced since their conception. Rust is very promising because of:\n An awesome toolchain with the cargo package manager with out-of-the-box documentation builder, unit test runner, childishly simple dependency management, etc. Full memory safety (unless explicitly turned off when you need to). Default immutability - variables are immutable by default, this way you will e.g. never forget to lock a resource in a thread before using it if it‚Äôs mutable. Clear, concise syntax - the syntax is clear, easy to read and above all - concise. Very informative, precise compiler errors and warnings - many times the compiler suggested an actual solution to the issue I was facing. Speed. It tends to be even faster than C++ in many situations.  Okay but just because I like Rust so much doesn‚Äôt mean everybody‚Äôs going to use it. So what indicators do we have at the moment that point to Rust slowly taking the market away from C++? Let‚Äôs look:\n Rust is now the second officially supported Linux kernel language. Amazon started sponsoring Rust in 2019 under their AWS brand, for example Amazon‚Äôs Firecracker micro-VM project is implemented in Rust. Microsoft is rewriting some of their projects into Rust. 5th most-wanted programming language of 2020. Named most loved programming language of 2020.  These are all big deals. Linux is the most used operating system in network servers, AWS the most popular cloud provider in the world, Microsoft owns a huge part of the operating system market as well as a good chunk of cloud computing market with its Azure platform. Hence these are all signals that if the pace is kept up, Rust might very well become a go-to for large-scale projects.\nDoes it pay off to learn C++ then? BIG FAT YES. Well, that‚Äôs a surprise. I go on bashing the language for the entire length of this article and then I drop that bombshell‚Ä¶\nHere‚Äôs the harsh inconvenient truth for people who dislike C++: the number of projects implemented in C and C++ to date and the sheer popularity of the language make it impossible to ignore if you want to do low(er)-level development professionally. If you‚Äôre a freelancer or a startup owner you might enforce Rust, sure, however most companies will still like to leverage troves of C++ talent that is available currently on the market instead of trying to source Rust developers which are still few and far between, albeit growing in numbers by the day.\nAll in all, C++ projects tend to create so much technical debt and tend to be so voluminous that it will take years before Rust can make a massive break. But I sincerely believe that it is the first language on the market that has what it takes to start replacing good old C++ or at least challenge its throne rights.\n","wordCount":"2116","inLanguage":"en","datePublished":"2021-12-21T22:34:07+01:00","dateModified":"2021-12-21T22:34:07+01:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://kjczarne.github.io/2021-12-21-c-is-the-new-cobol/"},"publisher":{"@type":"Organization","name":"Klebstoff","logo":{"@type":"ImageObject","url":"http://kjczarne.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=http://kjczarne.github.io/ accesskey=h title="Klebstoff (Alt + H)">Klebstoff</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=http://kjczarne.github.io/posts/ title=posts>
<span>posts</span>
</a>
</li>
<li>
<a href=http://kjczarne.github.io/search/ title="search (Alt + /)" accesskey=/>
<span>search</span>
</a>
</li>
<li>
<a href=http://kjczarne.github.io/tags/ title=tags>
<span>tags</span>
</a>
</li>
<li>
<a href=http://kjczarne.github.io/categories/ title=categories>
<span>categories</span>
</a>
</li>
<li>
<a href=http://kjczarne.github.io/about/ title=about>
<span>about</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
C++ is the new COBOL
</h1>
<div class=post-meta><span title="2021-12-21 22:34:07 +0100 +0100">December 21, 2021</span>&nbsp;¬∑&nbsp;10 min
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#the-problems-with-c aria-label="The problems with C++">The problems with C++</a><ul>
<li>
<a href=#c-is-extremely-verbose aria-label="C++ is extremely verbose">C++ is extremely verbose</a></li>
<li>
<a href=#it-takes-years-to-get-proficient-in-c aria-label="It takes years to get proficient in C++">It takes years to get proficient in C++</a></li>
<li>
<a href=#memory-safety-is-not-guaranteed aria-label="Memory safety is not guaranteed">Memory safety is not guaranteed</a></li>
<li>
<a href=#using-the-latest-standard-might-be-risky aria-label="Using the latest standard might be risky">Using the latest standard might be risky</a></li>
<li>
<a href=#figuring-out-build-systems-is-ridiculously-complicated aria-label="Figuring out build systems is ridiculously complicated">Figuring out build systems is ridiculously complicated</a></li>
<li>
<a href=#compiler-error-messages-can-be-next-to-useless aria-label="Compiler error messages can be next to useless">Compiler error messages can be next to useless</a></li></ul>
</li>
<li>
<a href=#ultimately-why-so-many-problems aria-label="Ultimately, why so many problems">Ultimately, why so many problems</a></li>
<li>
<a href=#why-i-think-c-is-heading-for-the-elysian-fields aria-label="Why I think C++ is heading for the Elysian Fields">Why I think C++ is heading for the Elysian Fields</a></li>
<li>
<a href=#does-it-pay-off-to-learn-c-then aria-label="Does it pay off to learn C++ then?">Does it pay off to learn C++ then?</a>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><p>C++ is a great language. As much as I hate it I cannot ignore how important it is and how much it brought to the table in it&rsquo;s 36 years of existence. I have tremendous respect for Bjarne Stroustrup for creating the so-called <em>C with classes</em> and I personally think that it&rsquo;s one of the best things that happened in programming language designs around the time when it came to existence.</p>
<p>But C++ is a language that we might slowly see becoming legacy technology. Here&rsquo;s my take on the whole C++ shebang.</p>
<blockquote>
<p>üëÄ For context: I started my career as a software developer with JavaScript and Python and then worked with C# for a good few months. I haven&rsquo;t touched C++ until a few months ago simply because I never had a need to. But there are situations in which you will need a much faster language that compiles to native code instead of something that always incurs a massive interpreter overhead. For the past two months I&rsquo;ve been learning C++ with the support of expert developers at work. My view may be a bit simplistic and I&rsquo;d enjoy to start a discussion and hear other views. I made sure it&rsquo;s not my resistance to change that makes me dislike C++ but this article naturally deals with some speculations about the future which we cannot know for certain, hence if you see that I&rsquo;ve overlooked something, don&rsquo;t hesitate to point it out.</p>
</blockquote>
<blockquote>
<p>üëâ In the examples below I will be using C++17 because that&rsquo;s what I&rsquo;m using at work. Keep in mind that some of the examples that I describe, e.g. template constraints have been added with the C++20 standard. Why aren&rsquo;t we using C++20? Well, using the latest standard is one of the problems I listed, so read on to learn more.</p>
</blockquote>
<h2 id=the-problems-with-c>The problems with C++<a hidden class=anchor aria-hidden=true href=#the-problems-with-c>#</a></h2>
<p>So, let&rsquo;s start with the reasons that I dislike C++. I like to call them <em>genuine problems</em>.</p>
<h3 id=c-is-extremely-verbose>C++ is extremely verbose<a hidden class=anchor aria-hidden=true href=#c-is-extremely-verbose>#</a></h3>
<p>Creating production-level code in C++ ofter requires a lot of boilerplate. This is bad because large codebases usually incur higher maintenance costs. On top of that, the syntax of the language doesn&rsquo;t make things better. Take for example the following <code>template</code> declaration which roughly corresponds to a very liberal <em>generic</em> type:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>void</span> do_something(T i) {
  <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>constexpr</span> (std<span style=color:#f92672>::</span>is_integral<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>&gt;</span>(array)) {
    <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>  } <span style=color:#66d9ef>else</span> {
    <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>  }
}
</code></pre></div><p>Compare that to a generic function in Rust:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>do_something</span><span style=color:#f92672>&lt;</span>T: <span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;</span>(i: <span style=color:#a6e22e>T</span>) -&gt; () {
    <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>}
</code></pre></div><p>This relative verbosity is prevalent in nearly all constructs. You quickly get sick of <code>std::string make_string_repr(std::shared_ptr&lt;MyClass>, std::string str_template)</code> and you promptly swivel your display from vertical orientation back to landscape (happened to me). In general C++ tends to be way more verbose than languages like Python, though you can learn to make things more concise over time. An expert friend of mine at work once refactored a function I&rsquo;ve created from 70 lines down to about 10. And this is a nice seguey into our next talking point&mldr;</p>
<h3 id=it-takes-years-to-get-proficient-in-c>It takes years to get proficient in C++<a hidden class=anchor aria-hidden=true href=#it-takes-years-to-get-proficient-in-c>#</a></h3>
<p>The complexity of the language entails this naturally - you cannot become a good junior developer within a few months. Well, at least if you&rsquo;re average like me, you will make a lot of mistakes especially at the very beginning of your journey. It is an immensely complex language especially for beginners or people comming from higher-level interpreted languages.</p>
<h3 id=memory-safety-is-not-guaranteed>Memory safety is not guaranteed<a hidden class=anchor aria-hidden=true href=#memory-safety-is-not-guaranteed>#</a></h3>
<p>Another issue/feature of C++ is the fact that the developer has to think about memory management very consciously all the time. For example, the following code compiles:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>do_something</span>() {
  <span style=color:#66d9ef>int</span> some_int;
  <span style=color:#75715e>// a lot of code ...
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> unknown_int_ptr;
  <span style=color:#75715e>// a lot of code ...
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> some_int_ptr <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>some_int;
}
</code></pre></div><p>Imagine that between the declaration of the integer and the declaration of the pointer you placed a lot of code and <em>nowhere</em> have you actually assigned a value to the <code>some_int</code> variable. This generally results in so-called undefined behavior, which is basically compiler-dependent and not guaranteed by the standard. So <code>some_int_ptr</code> when dereferenced will point to <code>some_int</code> but we cannot make any guarantees about its value, because it won&rsquo;t make any sense anyway. And <strong>this statement is legal in C++</strong> as it is in C.</p>
<p>Now to the <code>unknown_int_ptr</code>. Notice that it has no address assigned so it essentially is a pointer into nothingness. Again this code compiles. Some smarter compilers might point out that this might be a bug but that depends on the way you&rsquo;ve set up your build toolchain. If you dereference <code>unknown_int_ptr</code> you will actually attempt dereferencing a <code>nullptr</code> which is also undefined behavior and in some cases pretty hard to catch!</p>
<p>In Rust, this is explicitly disallowed when using references:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>do_something</span>() {
    <span style=color:#66d9ef>let</span> some_int: <span style=color:#66d9ef>u8</span>;                   <span style=color:#75715e>// won&#39;t compile!
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> unknown_int_ptr: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>u8</span>;           <span style=color:#75715e>// won&#39;t compile!
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> some_int_ptr: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>u8</span> <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>some_int;  <span style=color:#75715e>// won&#39;t compile!
</span><span style=color:#75715e></span>}
</code></pre></div><blockquote>
<p>üëÄ The reason why C and C++ do allow such silly operations is to give the developers maximum flexibility with their code. As such, it is the sole responsibility of the developer not to make such mistakes. (Un)fortunately developers are born to make mistakes. Rust takes a middle ground. It is <strong>still possible to do unsafe operations in Rust</strong>, albeit they need to be explicitly marked (placed in an <code>unsafe { }</code> block).</p>
</blockquote>
<blockquote>
<p>üëÄ Some of the pointer management problems can be averted by using the so-called <em>smart pointers</em> which have been added in C++17. You can even emulate Rust&rsquo;s ownership move logic with <code>std::unique_ptr&lt;T></code> template. If you&rsquo;re unsure what this all means just disregard this block.</p>
</blockquote>
<h3 id=using-the-latest-standard-might-be-risky>Using the latest standard might be risky<a hidden class=anchor aria-hidden=true href=#using-the-latest-standard-might-be-risky>#</a></h3>
<p>I didn&rsquo;t experience this personally but I&rsquo;ve heard of a commercial project (of which details I cannot disclose) that was implemented in C++17 back when C++17 was a freshly released standard. Long story short, the MSVC Compiler had a bug that caused the developers a lot of headaches before they were able to realize that their code is ok but the compiler is not. You would think that such things are unacceptable but bugs happen in every compiler or interpreter out there. The problem is -> when you&rsquo;re working with a complex language like C++ it&rsquo;s inherently more likely that someone at some point will make a mistake. And that means you have to put lower trust into something as important as the compiler for the language.</p>
<h3 id=figuring-out-build-systems-is-ridiculously-complicated>Figuring out build systems is ridiculously complicated<a hidden class=anchor aria-hidden=true href=#figuring-out-build-systems-is-ridiculously-complicated>#</a></h3>
<p>My first look at the CMake-based build system generator toolchain in a large commercial project almost made me want to sign up for a 3 month break from work at a mental asylum. Now listen&mldr;</p>
<p>In Python we usually need one or more <code>setup.cfg</code> files with a corresponding <code>setup.py</code> that loads it, finds the package files and the package is ready to be installed. Python uses the <code>pip</code> package manager for this, Node.JS has <code>npm</code> or <code>yarn</code> package managers, Rust has its absolutely phenomenal <code>cargo</code> package manager.</p>
<blockquote>
<p>ü§¶‚Äç‚ôÇÔ∏è <strong>C++ does not have any good package manager whatsoever</strong>.</p>
</blockquote>
<p>The closest we have to a <em>package manager</em> in C++ is the Conan package manager. So let&rsquo;s say I want to depend on a few packages in my C++ project. What do I do? <strong>I need to nearly write my own build system</strong> using CMake and use <a href=https://github.com/conan-io/cmake-conan/blob/develop/conan.cmake>Conan CMake files</a> to even be able to talk to the package manager when invoking <code>cmake</code>. CMake actually generates <code>Makefile</code> on Linux or Visual Studio Solution files on Windows. Well, not always, depends on how you configure it. Because you could replace <code>Makefile</code>-consuming <code>make</code> with <code>ninja</code> which can also be used as an alternative to MSBuild on Windows, MSBuild being the tool normally responsible for building Solution (<code>*.sln</code>) files. Then you have to remember that cached Conan packages can sometimes interfere with fresh builds if certain configuration options like the version of the compiler has changed in between builds, so does the CMake target directory with its <code>CMakeCacher.txt</code>&mldr; üò£</p>
<p>There&rsquo;s a beautiful German adjective that describes this situation perfectly: <a href=https://en.wiktionary.org/wiki/bescheuert><em>bescheuert</em></a>.</p>
<blockquote>
<p>üëâ In Rust to obtain packages necessary for a new project, all you need to do is add them to the list of dependencies in <code>Cargo.toml</code> and trigger a new project build. That&rsquo;s it. That&rsquo;s what dependency management should look like.</p>
</blockquote>
<h3 id=compiler-error-messages-can-be-next-to-useless>Compiler error messages can be next to useless<a hidden class=anchor aria-hidden=true href=#compiler-error-messages-can-be-next-to-useless>#</a></h3>
<p>Last but not least, if you&rsquo;ve ever compiled C++ code in your life you will know what I mean. The output produced by the compiler (especially MSVC) is usually quite uninformative and it often leads you on a wild goose chase. It happened to me lately that when using <code>fmt</code> I wasn&rsquo;t able to find an improper usage of a formatter function because the line number info was hidden somewhere in the middle of an outlandishly long stack trace and my eyes just kept on slipping through it. It&rsquo;s often very hard to debug weird compilation errors particularly where macros and templates are used.</p>
<h2 id=ultimately-why-so-many-problems>Ultimately, why so many problems<a hidden class=anchor aria-hidden=true href=#ultimately-why-so-many-problems>#</a></h2>
<p>C++ has so many issues because it&rsquo;s fairly old! Each new standard piled dubious <em>features</em> on top of the existing stuff with regards for maximum backwards-compatibility. Since a path has been taken with many language design choices, it is not really possible to now backtrack on certain decisions. Issues are being fixed and developer experience is being improved, albeit at a much slower pace than for most modern languages.</p>
<h2 id=why-i-think-c-is-heading-for-the-elysian-fields>Why I think C++ is heading for the Elysian Fields<a hidden class=anchor aria-hidden=true href=#why-i-think-c-is-heading-for-the-elysian-fields>#</a></h2>
<p>You might have noticed that all examples I&rsquo;ve provided for the <em>bad stuff</em> in C++, I&rsquo;ve countered with examples in Rust. So, here&rsquo;s my theory:</p>
<blockquote>
<p>üëâ I think Rust will replace C++ as the main systems development low(er)-level language within the next 20 years.</p>
</blockquote>
<p>If the pace of adoption of Rust Programming Language keeps up, we might see Rust being the language that solves some of the issues that C and C++ faced since their conception. Rust is very promising because of:</p>
<ul>
<li>An awesome toolchain with the <code>cargo</code> package manager with out-of-the-box documentation builder, unit test runner, childishly simple dependency management, etc.</li>
<li>Full memory safety (unless explicitly turned off when you need to).</li>
<li>Default immutability -> variables are immutable by default, this way you will e.g. never forget to lock a resource in a thread before using it if it&rsquo;s mutable.</li>
<li>Clear, concise syntax -> the syntax is clear, easy to read and above all - concise.</li>
<li>Very informative, precise compiler errors and warnings -> many times the compiler suggested an actual solution to the issue I was facing.</li>
<li>Speed. It tends to be even faster than C++ in many situations.</li>
</ul>
<p>Okay but just because I like Rust so much doesn&rsquo;t mean everybody&rsquo;s going to use it. So what indicators do we have at the moment that point to Rust slowly taking the market away from C++? Let&rsquo;s look:</p>
<ul>
<li>Rust is now the <a href=https://www.zdnet.com/article/rust-takes-a-major-step-forward-as-linuxs-second-official-language/>second officially supported Linux kernel language</a>.</li>
<li>Amazon <a href=https://aws.amazon.com/blogs/opensource/why-aws-loves-rust-and-how-wed-like-to-help/>started sponsoring Rust in 2019 under their AWS brand</a>, for example Amazon&rsquo;s Firecracker micro-VM project is <a href=https://firecracker-microvm.github.io/>implemented in Rust</a>.</li>
<li>Microsoft is <a href=https://thenewstack.io/microsoft-rust-is-the-industrys-best-chance-at-safe-systems-programming/>rewriting some of their projects into Rust</a>.</li>
<li><a href=https://insights.stackoverflow.com/survey/2020#technology-most-loved-dreaded-and-wanted-languages-wanted>5th most-wanted</a> programming language of 2020.</li>
<li>Named <a href=https://insights.stackoverflow.com/survey/2020#technology-most-loved-dreaded-and-wanted-languages-loved>most loved programming language of 2020</a>.</li>
</ul>
<p>These are all big deals. Linux is the most used operating system in network servers, AWS the most popular cloud provider in the world, Microsoft owns a huge part of the operating system market as well as a good chunk of cloud computing market with its Azure platform. Hence these are all signals that if the pace is kept up, Rust might very well become a go-to for large-scale projects.</p>
<h2 id=does-it-pay-off-to-learn-c-then>Does it pay off to learn C++ then?<a hidden class=anchor aria-hidden=true href=#does-it-pay-off-to-learn-c-then>#</a></h2>
<p><strong>BIG FAT YES</strong>. Well, that&rsquo;s a surprise. I go on bashing the language for the entire length of this article and then I drop that bombshell&mldr;</p>
<p>Here&rsquo;s the harsh inconvenient truth for people who dislike C++: the number of projects implemented in C and C++ to date and the sheer popularity of the language make it impossible to ignore if you want to do low(er)-level development professionally. If you&rsquo;re a freelancer or a startup owner you might enforce Rust, sure, however most companies will still like to leverage troves of C++ talent that is available currently on the market instead of trying to source Rust developers which are still few and far between, albeit growing in numbers by the day.</p>
<p>All in all, C++ projects tend to create so much technical debt and tend to be so voluminous that it will take years before Rust can make a massive break. But I sincerely believe that it is the first language on the market that has what it takes to start replacing good old C++ or at least challenge its throne rights.</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=http://kjczarne.github.io/tags/programming-languages/>programming-languages</a></li>
</ul>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share C++ is the new COBOL on twitter" href="https://twitter.com/intent/tweet/?text=C%2b%2b%20is%20the%20new%20COBOL&url=http%3a%2f%2fkjczarne.github.io%2f2021-12-21-c-is-the-new-cobol%2f&hashtags=programming-languages"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share C++ is the new COBOL on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fkjczarne.github.io%2f2021-12-21-c-is-the-new-cobol%2f&title=C%2b%2b%20is%20the%20new%20COBOL&summary=C%2b%2b%20is%20the%20new%20COBOL&source=http%3a%2f%2fkjczarne.github.io%2f2021-12-21-c-is-the-new-cobol%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share C++ is the new COBOL on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fkjczarne.github.io%2f2021-12-21-c-is-the-new-cobol%2f&title=C%2b%2b%20is%20the%20new%20COBOL"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share C++ is the new COBOL on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fkjczarne.github.io%2f2021-12-21-c-is-the-new-cobol%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share C++ is the new COBOL on whatsapp" href="https://api.whatsapp.com/send?text=C%2b%2b%20is%20the%20new%20COBOL%20-%20http%3a%2f%2fkjczarne.github.io%2f2021-12-21-c-is-the-new-cobol%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share C++ is the new COBOL on telegram" href="https://telegram.me/share/url?text=C%2b%2b%20is%20the%20new%20COBOL&url=http%3a%2f%2fkjczarne.github.io%2f2021-12-21-c-is-the-new-cobol%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer><div id=disqus_thread></div>
<script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//kjczarne.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script>
<noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript>
<a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a>
<script type=text/javascript src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>mermaid.initialize({startOnLoad:!0,securityLevel:'loose'})</script>
<script>window.onload=function(){mermaid.init(void 0,".language-mermaid")}</script>
</article>
</main>
<footer class=footer>
<span>Copyright 2021 Krzysztof J. Czarnecki. Fair use permitted with authorship attribution. Commercial use disallowed without explicit permission. Some links in blog articles are affiliate links when noted.</span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>