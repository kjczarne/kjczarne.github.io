[{"content":"About me I am a Software Developer at Technica Engineering GmbH with a focus on process automation, continuous integration systems and infrastructure tooling. I am currently involved in projects related to the automation of hardware testing in the automotive domain. I speak Python, C#, F#, TypeScript and to a lesser degree Rust. I despise C++.\nMy original domain is Biotechnology with focus on Genetics and Epigenetics. I have a B.Sc. degree in Biotechnology and am an alumnus of Data Science Retreat Deep Learning Bootcamp.\n","permalink":"http://kjczarne.github.io/about/","summary":"About me I am a Software Developer at Technica Engineering GmbH with a focus on process automation, continuous integration systems and infrastructure tooling. I am currently involved in projects related to the automation of hardware testing in the automotive domain. I speak Python, C#, F#, TypeScript and to a lesser degree Rust. I despise C++.\nMy original domain is Biotechnology with focus on Genetics and Epigenetics. I have a B.Sc. degree in Biotechnology and am an alumnus of Data Science Retreat Deep Learning Bootcamp.","title":"About Me"},{"content":"Sin number 1: Do not modify builtins and globals This is one of the biggest no-nos for me and something that I shot myself in the foot at least twice in my career as a Python dev. I\u0026rsquo;ve also seen this used in actual production code that was deployed to some important clients.\nWhence the temptation?  builtins is a collection of objects that are available from within any Python script and are loaded before any script is executed by the interpreter. If you\u0026rsquo;ve ever used int, bytes, dict, list, etc. then these all come from builtins. globals is a collection of objects that exist in current global scope, so objects accessible to any module at a particular point in time when your script is running.   ðŸ‘‰ It is tempting to modify the builtins to expose a particular custom function or object globally to any running Python script without the need to import a module explicitly. Likewise the modification of globals can enable such magic as dynamic imports of modules that are a part of the same package without actually using the explicit module names.\n Why is this a sin? In both cases it makes your code less explicit and modifies global interpreter behavior after builtins or globals have been modified. The implications of this are:\n Nobody understands your code -\u0026gt; you\u0026rsquo;re using symbols that were sneakily imported at some point but no person using your code will be able to easily tell what module they came from and what they do. It often breaks code suggestions -\u0026gt; implicilty imported stuff may not be picked up by language analysis tools that try to determine the validity of statements in your code. It creates a potential for name collisions -\u0026gt; if you were to e.g. define your own map function and then tried adding it to builtins you could inadvertently override a built-in map function. Such blunders are extremely hard to debug.  How to recognize a sinner? The following example function walks two steps into an src submodule and looks for classes that are subclasses of ImportMe and ImportMeToo. It then adds them to globals, which can be used in current scope.\ndef walking_import(): from mod import src for _, name, _ in pkgutil.walk_packages(src.__path__): _temp = importlib.import_module(src.__package__ + \u0026#39;.\u0026#39; + name) for _, n, _ in pkgutil.walk_packages(_temp.__path__): _temp2 = importlib.import_module(_temp.__package__ + \u0026#39;.\u0026#39; + n) for n2, m in inspect.getmembers(_temp2, inspect.isclass): if issubclass(m, ImportMe) or issubclass(m, ImportMeToo): globals()[n2] = m return globals() This is a real function (though slightly redacted) that I once put into production code. A few weeks later we had to change the import sequence in the entire package back to what it used to be because modifying globals made IntelliSense useless and nobody could make sense of the code.\nHow to repent? My advice: never modify globals or builtins. If you find yourself doing that then probably something is fundamentally wrong with the design of your application. If you\u0026rsquo;re a novice make sure to consult your application design with somebody who has more experience. Prefer explicit imports and as little import magic as possible.\n ðŸ‘€ Where import magic was usually useful for me was when I wanted to load entire Python scripts as configuration files. Even though I would use importlib and inspect modules for that, I would never touch globals or builtins.\n ","permalink":"http://kjczarne.github.io/posts/seven-sins-of-python-sin-1/","summary":"Sin number 1: Do not modify builtins and globals This is one of the biggest no-nos for me and something that I shot myself in the foot at least twice in my career as a Python dev. I\u0026rsquo;ve also seen this used in actual production code that was deployed to some important clients.\nWhence the temptation?  builtins is a collection of objects that are available from within any Python script and are loaded before any script is executed by the interpreter.","title":"Seven Sins of Python - Sin 1"},{"content":"Seven Sins of Python - intro Python is not only the most popular programming language (according to TIOBE as of 2021) but also one of the simplest to work with and easiest to learn. Python is great for a wide range of applications from web development through command line tools to large-scale automation and deep learning projects.\nIt is far from the snappiest programming languages in terms of performance, however many other languages can be used alongside Python when performance is of essence.\nBecause it\u0026rsquo;s so easy to do anything in Python, it\u0026rsquo;s also incredibly easy to do things that are at best slight stumbles and at worst critical design mistakes that may make any project unmaintainable and even unstable in the long run. As someone who codes predominantly in Python, I\u0026rsquo;ve seen some terrible patterns used in commercial products but I\u0026rsquo;ve also had the misfortune of becoming a victim of a few of those myself.\nHere is what I think are the 7 biggest mistakes that could be a part of any application. In my humble opinion, you should avoid these at all cost. As with all cults, this is one prophet\u0026rsquo;s gospel. You might find yourself disagreeing with one or more of these statements, perhaps even all of them. That\u0026rsquo;s ok.\nHow to read this article Each section that follows will be split up into clear components:\n Whence the temptation? -\u0026gt; explains why developers tend to use a particular antipattern Why is this a sin? -\u0026gt; explains why a particular practice is an antipattern How to recognize a sinner? -\u0026gt; provides an example of the antipattern How to repent? -\u0026gt; provides a better alternative to the antipattern  ","permalink":"http://kjczarne.github.io/posts/seven-sins-of-python-intro/","summary":"Seven Sins of Python - intro Python is not only the most popular programming language (according to TIOBE as of 2021) but also one of the simplest to work with and easiest to learn. Python is great for a wide range of applications from web development through command line tools to large-scale automation and deep learning projects.\nIt is far from the snappiest programming languages in terms of performance, however many other languages can be used alongside Python when performance is of essence.","title":"Seven Sins of Python - Intro"}]