[{"content":"Here are links to some of the Jupyter Notebooks mentioned in my blog posts:\n Python - timing builtins vs. loops  ","permalink":"http://kjczarne.github.io/nb/","summary":"Here are links to some of the Jupyter Notebooks mentioned in my blog posts:\n Python - timing builtins vs. loops  ","title":"Notebooks"},{"content":"Sin number 2: too few optimized functions used This one is pretty common especially for newcomers who have learnt enough about Python to be able to loop over data structures but haven\u0026rsquo;t yet realized how slow Python loops really are.\nWhence the temptation? If you\u0026rsquo;re fresh to Python, the temptation to create for loops everywhere for lists and dictionaries is immense. Consider a fairly simple example, where we loop over 100000 random integers and we apply a simple mathematical operation to each of those integers. The most straightforward solution would be:\nfor i in random_integers: out_list.append(perform_predefined_calculation(i)) (assumming here that perform_predefined_calculation and random_integer exist)\nA slightly more Pythonic way to express this would be:\nout_list = [perform_predefined_calculation(i) for i in random_integers] Why is this a sin? While it might be ok for small data structures, the problem with all kinds of loops in Python is that they\u0026rsquo;re pretty slow in comparison with functional constructs such as map or filter. Why is that? Python is an interpreted language, so every statement is evaluated at runtime, there is no compilation process. But functions like map and filter were actually implemented in C (well, at least if you\u0026rsquo;re using the most widespread CPython) and C code can be, well\u0026hellip; pretty fast.\nThe test I\u0026rsquo;ve ran showed about 30% performance increase with a simple refactor from a for loop to a list(map(f, x)) idiom.\nYou can do your own timings on your own and modify the examples as you please in this Python notebook.\nHow to recognize a sinner? Our sinners will most likely be individuals less experienced with Python and can be recognized by profilic abuse of loops whenever working with iterable data structures. Every professional will also often use for and less often while, however performance-critical parts of code where a large amount of data is expected will almost always be brimming with the functional idioms.\nHow to repent?  It\u0026rsquo;s okay to use for and while but not where you need fast code. Learn to use at least map, filter and functools.reduce. Refactor code that iderates over large data structures to use the aforementioned functions.  In our particular example, the repentance is easy and gives us code nearly as pretty as the list comprehension used before:\nout_list = list(map(perform_predefined_calculation, random_integers))  ðŸ‘€ map applies perform_predefined_calculation function to each element of the random_integers list. map is lazy so it will only run when we iterate over the result at some point. To load the output as a standard Python list, we can simply wrap it into a list() call. The output will be thus exactly the same as originally but we\u0026rsquo;ll be able to obtain it much faster.\n ","permalink":"http://kjczarne.github.io/2021-12-16-seven-sins-of-python-sin-2/","summary":"Sin number 2: too few optimized functions used This one is pretty common especially for newcomers who have learnt enough about Python to be able to loop over data structures but haven\u0026rsquo;t yet realized how slow Python loops really are.\nWhence the temptation? If you\u0026rsquo;re fresh to Python, the temptation to create for loops everywhere for lists and dictionaries is immense. Consider a fairly simple example, where we loop over 100000 random integers and we apply a simple mathematical operation to each of those integers.","title":"Seven Sins of Python Sin 2"},{"content":"I am a Software Developer at Technica Engineering GmbH with a focus on process automation, continuous integration systems and infrastructure tooling. I am currently involved in projects related to the automation of hardware testing in the automotive domain. I speak Python, C#, F#, TypeScript and to a lesser degree Rust. I despise C++.\nMy original domain is Biotechnology with focus on Genetics and Epigenetics. I have a B.Sc. degree in Biotechnology and am an alumnus of Data Science Retreat Deep Learning Bootcamp.\n","permalink":"http://kjczarne.github.io/about/","summary":"I am a Software Developer at Technica Engineering GmbH with a focus on process automation, continuous integration systems and infrastructure tooling. I am currently involved in projects related to the automation of hardware testing in the automotive domain. I speak Python, C#, F#, TypeScript and to a lesser degree Rust. I despise C++.\nMy original domain is Biotechnology with focus on Genetics and Epigenetics. I have a B.Sc. degree in Biotechnology and am an alumnus of Data Science Retreat Deep Learning Bootcamp.","title":"About Me"},{"content":"Sin number 1: Do not modify builtins and globals This is one of the biggest no-nos for me and something that I shot myself in the foot at least twice in my career as a Python dev. I\u0026rsquo;ve also seen this used in actual production code that was deployed to some important clients.\nWhence the temptation?  builtins is a collection of objects that are available from within any Python script and are loaded before any script is executed by the interpreter. If you\u0026rsquo;ve ever used int, bytes, dict, list, etc. then these all come from builtins. globals is a collection of objects that exist in current global scope, so objects accessible to any module at a particular point in time when your script is running.   ðŸ‘‰ It is tempting to modify the builtins to expose a particular custom function or object globally to any running Python script without the need to import a module explicitly. Likewise the modification of globals can enable such magic as dynamic imports of modules that are a part of the same package without actually using the explicit module names.\n Why is this a sin? In both cases it makes your code less explicit and modifies global interpreter behavior after builtins or globals have been modified. The implications of this are:\n Nobody understands your code -\u0026gt; you\u0026rsquo;re using symbols that were sneakily imported at some point but no person using your code will be able to easily tell what module they came from and what they do. It often breaks code suggestions -\u0026gt; implicilty imported stuff may not be picked up by language analysis tools that try to determine the validity of statements in your code. It creates a potential for name collisions -\u0026gt; if you were to e.g. define your own map function and then tried adding it to builtins you could inadvertently override a built-in map function. Such blunders are extremely hard to debug.  How to recognize a sinner? The following example function walks two steps into an src submodule and looks for classes that are subclasses of ImportMe and ImportMeToo. It then adds them to globals, which can be used in current scope.\ndef walking_import(): from mod import src for _, name, _ in pkgutil.walk_packages(src.__path__): _temp = importlib.import_module(src.__package__ + \u0026#39;.\u0026#39; + name) for _, n, _ in pkgutil.walk_packages(_temp.__path__): _temp2 = importlib.import_module(_temp.__package__ + \u0026#39;.\u0026#39; + n) for n2, m in inspect.getmembers(_temp2, inspect.isclass): if issubclass(m, ImportMe) or issubclass(m, ImportMeToo): globals()[n2] = m return globals() This is a real function (though slightly redacted) that I once put into production code. A few weeks later we had to change the import sequence in the entire package back to what it used to be because modifying globals made IntelliSense useless and nobody could make sense of the code.\nHow to repent? My advice: never modify globals or builtins. If you find yourself doing that then probably something is fundamentally wrong with the design of your application. If you\u0026rsquo;re a novice make sure to consult your application design with somebody who has more experience. Prefer explicit imports and as little import magic as possible.\n ðŸ‘€ Where import magic was usually useful for me was when I wanted to load entire Python scripts as configuration files. Even though I would use importlib and inspect modules for that, I would never touch globals or builtins.\n ","permalink":"http://kjczarne.github.io/2021-12-10-seven-sins-of-python-sin-1/","summary":"Sin number 1: Do not modify builtins and globals This is one of the biggest no-nos for me and something that I shot myself in the foot at least twice in my career as a Python dev. I\u0026rsquo;ve also seen this used in actual production code that was deployed to some important clients.\nWhence the temptation?  builtins is a collection of objects that are available from within any Python script and are loaded before any script is executed by the interpreter.","title":"Seven Sins of Python - Sin 1"},{"content":"Seven Sins of Python - intro Python is not only the most popular programming language (according to TIOBE as of 2021) but also one of the simplest to work with and easiest to learn. Python is great for a wide range of applications from web development through command line tools to large-scale automation and deep learning projects.\nIt is far from the snappiest programming languages in terms of performance, however many other languages can be used alongside Python when performance is of essence.\nBecause it\u0026rsquo;s so easy to do anything in Python, it\u0026rsquo;s also incredibly easy to do things that are at best slight stumbles and at worst critical design mistakes that may make any project unmaintainable and even unstable in the long run. As someone who codes predominantly in Python, I\u0026rsquo;ve seen some terrible patterns used in commercial products but I\u0026rsquo;ve also had the misfortune of becoming a victim of a few of those myself.\nThis series describes what I think are the 7 biggest mistakes that could be a part of any application. In my humble opinion, you should avoid these at all cost. As with all cults, this is one prophet\u0026rsquo;s gospel. You might find yourself disagreeing with one or more of these statements, perhaps even all of them. That\u0026rsquo;s ok.\nHow to read the series articles Each section that follows will be split up into clear components:\n Whence the temptation? -\u0026gt; explains why developers tend to use a particular antipattern Why is this a sin? -\u0026gt; explains why a particular practice is an antipattern How to recognize a sinner? -\u0026gt; provides an example of the antipattern How to repent? -\u0026gt; provides a better alternative to the antipattern  ","permalink":"http://kjczarne.github.io/2021-12-10-seven-sins-of-python-intro/","summary":"Seven Sins of Python - intro Python is not only the most popular programming language (according to TIOBE as of 2021) but also one of the simplest to work with and easiest to learn. Python is great for a wide range of applications from web development through command line tools to large-scale automation and deep learning projects.\nIt is far from the snappiest programming languages in terms of performance, however many other languages can be used alongside Python when performance is of essence.","title":"Seven Sins of Python - Intro"}]