[{"content":"Sin number 3: Unconditional romance with ducktyping Whence the temptation? Python is truly awesome. In C++17 there is no easy way of expressing ranges. In Python an integer range \\(\\langle 0, 4 \\rangle\\) is simply range(0, 5).\nThe syntactic simplicity and high conciseness of the language was originally related to the fact that Python does not have static typing. In Python ducktyping means that you can actually call a function that expects an integer with a string and you will likely only realize at runtime, since there is no compilation step. It makes coding in Python, well\u0026hellip; very easy to begin with but it comes at a huge cost of bugs appearing in production code.\nWhy is this a sin? Actually, let\u0026rsquo;s make it an example:\ndef add_two_ints(x, y): return x + y If we call this like add_two_ints(2, 2), we will get 4.\nWhat will we get if we invoke add_two_ints(2, \u0026quot;lol\u0026quot;)? Is it even possible? Well, kind of. You can call the function but you will get a runtime error:\nTypeError: unsupported operand type(s) for +: \u0026#39;int\u0026#39; and \u0026#39;str\u0026#39; Adding a 2 to a \u0026quot;lol\u0026quot; string is quite ambiguous and in most cases probably a bug so the interpreter throws an error. But notice that we were able to call the function and there was no type checking happening up to the point of x + y operation.\nIf we tweak this function slightly:\ndef add_two_ints(x, y): print(f\u0026#34;x is {x}, y is {y}\u0026#34;) return x + y The print will run just fine and give us \u0026quot;x is 2, y is 2\u0026quot;! So the input was not checked in any way before the function body has been executed.\nThe example is trivial. But as your code expands, these problems will grow out of control very quickly. We should have a way of controlling the types of input values we\u0026rsquo;re invoking the function with.\nHow to recognize a sinner? Sinners will use bare Python without type hints (which we\u0026rsquo;ll discuss as a solution in the next section) or in the worst instance no facilities for type checking. To make it clearer:\nBad solution The exact example we used originally is a prime example of the worst solution possible:\ndef add_two_ints(x, y): return x + y Slightly better solution A slightly improved variant would actually check the types of arguments at runtime:\ndef add_two_ints(x, y): if type(x) is not int and type(x) is not int: raise ValueError(f\u0026#34;This function accepts only integers as parameters! Called with {x}and {y}\u0026#34;) return x + y However when writing code in any modern editor (e.g. VSCode with Pylance Server or JetBrains PyCharm), the language analyzer will not catch any bad invocations as you write your code. You have to run it to see where it fails and that\u0026rsquo;s suboptimal in terms of development speed and it tends to get very frustrating.\nIf you place the following somewhere else in your code, perhaps in a different module where you import your brand new add_two_ints function:\nadd_two_ints(2, \u0026#34;lol\u0026#34;) Your editor will not tell you that you\u0026rsquo;re using the wrong arguments until you run the script.\nHow to repent? There is one extremely important feature that has been added in Python 3.5 and solves the aforementioned problem: type hints. The advantage of using type hints over bare runtime checking is that you can catch type mismatch issues before you run your code. First you would have to refactor the function slightly:\ndef add_two_ints(x: int, y: int) -\u0026gt; int: if type(x) is not int and type(x) is not int: raise ValueError(f\u0026#34;This function accepts only integers as parameters! Called with {x}and {y}\u0026#34;) return x + y This gives you the following benefits:\n add_two_ints(x: int, y: int) -\u0026gt; int describes the entire signature of the function. Most analysis services like the Python Language Server in VSCode will be able to suggest you what type the input parameters are while you\u0026rsquo;re coding. The aforementioned Language Server will also display a red squiggle under each parameter that is of an unexpected type, hence it will notify you of mistakes like add_two_ints(2, \u0026quot;lol\u0026quot;) while you\u0026rsquo;re coding. You can force every contributor to use type hints where they\u0026rsquo;re required by using static type checkers like pyright by running this in your code acceptance pipelines.  Important question: does this absolve me from runtime parameter checking? Well, it doesn\u0026rsquo;t prevent anyone from still conjuring deamons like add_two_ints(2, \u0026quot;lol\u0026quot;) but at least it will give them a hint if they themselves use something that comes at least close to what VSCode+Pylance can provide.\nIn the end my recommendations would be:\n ðŸ‘‰ Use type hints aggressively. Invest ample time into learning about type aliases, hints for generics, etc. There is a lot of resources out there but if you want a fairly condensed overview, throw in a comment and I\u0026rsquo;ll share my own reference sheet. Good news: it\u0026rsquo;s so easy and intuitive that it will enter your muscle memory within a few days.\n  ðŸ‘‰ Use VSCode with the Pylance Python Language Server. It understands type hints and tells you right away when you\u0026rsquo;re attempting something you shouldn\u0026rsquo;t be doing. Or really just use any other IDE or editor that understands type hints.\n  ðŸ‘‰ If you want to be absolutely certain that whoever uses your code doesn\u0026rsquo;t pass a wrong parameter, use runtime type checking and throw informative errors to let the user understand where the error came from.\n  ðŸ‘€ Trust me when I say this: you wouldn\u0026rsquo;t believe how many bugs having static type information is able to catch. When you\u0026rsquo;re typing for hours on end you will get tired. You will overlook things. You will get distracted. If you really want high-quality code that will be easier to maintain, use every possibility to be your own adversary and try to catch your own mistakes.\n While it\u0026rsquo;s lately become a controversial topic to exactly quantify how much more catching a bug in production than in development costs, there have been some ridiculous examples of bugs costing companies hundreds of millions of dollars. Pareto principle definitely applies here, putting too many safeguards into your code acceptance pipeline may actually decrease productivity if you go overboard. Type hints however gave me personally the biggest bang for the buck when it comes to code quality assurance, that\u0026rsquo;s why I am so bullish on them.\n","permalink":"http://kjczarne.github.io/2021-12-17-seven-sins-of-python-sin-3/","summary":"Sin number 3: Unconditional romance with ducktyping Whence the temptation? Python is truly awesome. In C++17 there is no easy way of expressing ranges. In Python an integer range \\(\\langle 0, 4 \\rangle\\) is simply range(0, 5).\nThe syntactic simplicity and high conciseness of the language was originally related to the fact that Python does not have static typing. In Python ducktyping means that you can actually call a function that expects an integer with a string and you will likely only realize at runtime, since there is no compilation step.","title":"Seven Sins of Python - Sin 3"},{"content":"Here are links to some of the Jupyter Notebooks mentioned in my blog posts:\n Python - timing builtins vs. loops  ","permalink":"http://kjczarne.github.io/nb/","summary":"Here are links to some of the Jupyter Notebooks mentioned in my blog posts:\n Python - timing builtins vs. loops  ","title":"Notebooks"},{"content":"Sin number 2: too few optimized functions used This one is pretty common especially for newcomers who have learnt enough about Python to be able to loop over data structures but haven\u0026rsquo;t yet realized how slow Python loops really are.\nWhence the temptation? If you\u0026rsquo;re fresh to Python, the temptation to create for loops everywhere for lists and dictionaries is immense. Consider a fairly simple example, where we loop over 100000 random integers and we apply a simple mathematical operation to each of those integers. The most straightforward solution would be:\nfor i in random_integers: out_list.append(perform_predefined_calculation(i)) (assumming here that perform_predefined_calculation and random_integer exist)\nA slightly more Pythonic way to express this would be:\nout_list = [perform_predefined_calculation(i) for i in random_integers] Why is this a sin? While it might be ok for small data structures, the problem with all kinds of loops in Python is that they\u0026rsquo;re pretty slow in comparison with functional constructs such as map or filter. Why is that? Python is an interpreted language, so every statement is evaluated at runtime, there is no compilation process. But functions like map and filter were actually implemented in C (well, at least if you\u0026rsquo;re using the most widespread CPython) and C code can be, well\u0026hellip; pretty fast.\nThe test I\u0026rsquo;ve ran showed about 30% performance increase with a simple refactor from a for loop to a list(map(f, x)) idiom.\nYou can do your own timings on your own and modify the examples as you please in this Python notebook.\nHow to recognize a sinner? Our sinners will most likely be individuals less experienced with Python and can be recognized by profilic abuse of loops whenever working with iterable data structures. Every professional will also often use for and less often while, however performance-critical parts of code where a large amount of data is expected will almost always be brimming with the functional idioms.\nHow to repent?  It\u0026rsquo;s okay to use for and while but not where you need fast code. Learn to use at least map, filter and functools.reduce. Refactor code that iderates over large data structures to use the aforementioned functions.  In our particular example, the repentance is easy and gives us code nearly as pretty as the list comprehension used before:\nout_list = list(map(perform_predefined_calculation, random_integers))  ðŸ‘€ map applies perform_predefined_calculation function to each element of the random_integers list. map is lazy so it will only run when we iterate over the result at some point. To load the output as a standard Python list, we can simply wrap it into a list() call. The output will be thus exactly the same as originally but we\u0026rsquo;ll be able to obtain it much faster.\n ","permalink":"http://kjczarne.github.io/2021-12-16-seven-sins-of-python-sin-2/","summary":"Sin number 2: too few optimized functions used This one is pretty common especially for newcomers who have learnt enough about Python to be able to loop over data structures but haven\u0026rsquo;t yet realized how slow Python loops really are.\nWhence the temptation? If you\u0026rsquo;re fresh to Python, the temptation to create for loops everywhere for lists and dictionaries is immense. Consider a fairly simple example, where we loop over 100000 random integers and we apply a simple mathematical operation to each of those integers.","title":"Seven Sins of Python - Sin 2"},{"content":"I am a Software Developer at Technica Engineering GmbH with a focus on process automation, continuous integration systems and infrastructure tooling. I am currently involved in projects related to the automation of hardware testing in the automotive domain. I speak Python, C#, F#, TypeScript and to a lesser degree Rust. I despise C++.\nMy original domain is Biotechnology with focus on Genetics and Epigenetics. I have a B.Sc. degree in Biotechnology and am an alumnus of Data Science Retreat Deep Learning Bootcamp.\n","permalink":"http://kjczarne.github.io/about/","summary":"I am a Software Developer at Technica Engineering GmbH with a focus on process automation, continuous integration systems and infrastructure tooling. I am currently involved in projects related to the automation of hardware testing in the automotive domain. I speak Python, C#, F#, TypeScript and to a lesser degree Rust. I despise C++.\nMy original domain is Biotechnology with focus on Genetics and Epigenetics. I have a B.Sc. degree in Biotechnology and am an alumnus of Data Science Retreat Deep Learning Bootcamp.","title":"About Me"},{"content":"Sin number 1: Do not modify builtins and globals This is one of the biggest no-nos for me and something that I shot myself in the foot at least twice in my career as a Python dev. I\u0026rsquo;ve also seen this used in actual production code that was deployed to some important clients.\nWhence the temptation?  builtins is a collection of objects that are available from within any Python script and are loaded before any script is executed by the interpreter. If you\u0026rsquo;ve ever used int, bytes, dict, list, etc. then these all come from builtins. globals is a collection of objects that exist in current global scope, so objects accessible to any module at a particular point in time when your script is running.   ðŸ‘‰ It is tempting to modify the builtins to expose a particular custom function or object globally to any running Python script without the need to import a module explicitly. Likewise the modification of globals can enable such magic as dynamic imports of modules that are a part of the same package without actually using the explicit module names.\n Why is this a sin? In both cases it makes your code less explicit and modifies global interpreter behavior after builtins or globals have been modified. The implications of this are:\n Nobody understands your code -\u0026gt; you\u0026rsquo;re using symbols that were sneakily imported at some point but no person using your code will be able to easily tell what module they came from and what they do. It often breaks code suggestions -\u0026gt; implicilty imported stuff may not be picked up by language analysis tools that try to determine the validity of statements in your code. It creates a potential for name collisions -\u0026gt; if you were to e.g. define your own map function and then tried adding it to builtins you could inadvertently override a built-in map function. Such blunders are extremely hard to debug.  How to recognize a sinner? The following example function walks two steps into an src submodule and looks for classes that are subclasses of ImportMe and ImportMeToo. It then adds them to globals, which can be used in current scope.\ndef walking_import(): from mod import src for _, name, _ in pkgutil.walk_packages(src.__path__): _temp = importlib.import_module(src.__package__ + \u0026#39;.\u0026#39; + name) for _, n, _ in pkgutil.walk_packages(_temp.__path__): _temp2 = importlib.import_module(_temp.__package__ + \u0026#39;.\u0026#39; + n) for n2, m in inspect.getmembers(_temp2, inspect.isclass): if issubclass(m, ImportMe) or issubclass(m, ImportMeToo): globals()[n2] = m return globals() This is a real function (though slightly redacted) that I once put into production code. A few weeks later we had to change the import sequence in the entire package back to what it used to be because modifying globals made IntelliSense useless and nobody could make sense of the code.\nHow to repent? My advice: never modify globals or builtins. If you find yourself doing that then probably something is fundamentally wrong with the design of your application. If you\u0026rsquo;re a novice make sure to consult your application design with somebody who has more experience. Prefer explicit imports and as little import magic as possible.\n ðŸ‘€ Where import magic was usually useful for me was when I wanted to load entire Python scripts as configuration files. Even though I would use importlib and inspect modules for that, I would never touch globals or builtins.\n ","permalink":"http://kjczarne.github.io/2021-12-10-seven-sins-of-python-sin-1/","summary":"Sin number 1: Do not modify builtins and globals This is one of the biggest no-nos for me and something that I shot myself in the foot at least twice in my career as a Python dev. I\u0026rsquo;ve also seen this used in actual production code that was deployed to some important clients.\nWhence the temptation?  builtins is a collection of objects that are available from within any Python script and are loaded before any script is executed by the interpreter.","title":"Seven Sins of Python - Sin 1"},{"content":"Seven Sins of Python - intro Python is not only the most popular programming language (according to TIOBE as of 2021) but also one of the simplest to work with and easiest to learn. Python is great for a wide range of applications from web development through command line tools to large-scale automation and deep learning projects.\nIt is far from the snappiest programming languages in terms of performance, however many other languages can be used alongside Python when performance is of essence.\nBecause it\u0026rsquo;s so easy to do anything in Python, it\u0026rsquo;s also incredibly easy to do things that are at best slight stumbles and at worst critical design mistakes that may make any project unmaintainable and even unstable in the long run. As someone who codes predominantly in Python, I\u0026rsquo;ve seen some terrible patterns used in commercial products but I\u0026rsquo;ve also had the misfortune of becoming a victim of a few of those myself.\nThis series describes what I think are the 7 biggest mistakes that could be a part of any application. In my humble opinion, you should avoid these at all cost. As with all cults, this is one prophet\u0026rsquo;s gospel. You might find yourself disagreeing with one or more of these statements, perhaps even all of them. That\u0026rsquo;s ok.\nHow to read the series articles Each section that follows will be split up into clear components:\n Whence the temptation? -\u0026gt; explains why developers tend to use a particular antipattern Why is this a sin? -\u0026gt; explains why a particular practice is an antipattern How to recognize a sinner? -\u0026gt; provides an example of the antipattern How to repent? -\u0026gt; provides a better alternative to the antipattern  ","permalink":"http://kjczarne.github.io/2021-12-10-seven-sins-of-python-intro/","summary":"Seven Sins of Python - intro Python is not only the most popular programming language (according to TIOBE as of 2021) but also one of the simplest to work with and easiest to learn. Python is great for a wide range of applications from web development through command line tools to large-scale automation and deep learning projects.\nIt is far from the snappiest programming languages in terms of performance, however many other languages can be used alongside Python when performance is of essence.","title":"Seven Sins of Python - Intro"}]